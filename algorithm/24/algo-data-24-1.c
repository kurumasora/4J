/*
 * ファイル名: algo-data-24-1.c
 * プロジェクト名: algo-data-24-1
 * * 概要: 行列の連鎖積を求める動的計画法を用いたアルゴリズム (アルゴリズム11.6) の実装
 */

#include <stdio.h>
#include <limits.h> // "無限"を表現するために INT_MAX を使用します

// 行列の最大数（必要に応じて変更可能）
#define MAX_N 100

int main(void) {
    int n; // 行列の個数
    
    /* * [入力の仕様について]
     * アルゴリズム11.6の変数に合わせて、配列 R (行数) と C (列数) を用意します。
     * アルゴリズムの添字が 1 から始まっているため、サイズを +1 して確保し、
     * 添字 1 から n を使用します。
     */
    int r[MAX_N + 1];
    int c[MAX_N + 1];
    int M[MAX_N + 1][MAX_N + 1];

    // 1. 行列の個数を入力
    printf("行列の個数 n を入力してください: ");
    if (scanf("%d", &n) != 1 || n <= 0 || n > MAX_N) {
        fprintf(stderr, "エラー: n は 1 から %d の範囲で入力してください。\n", MAX_N);
        return 1;
    }

    // 2. 各行列の行数と列数を入力
    // アルゴリズムの要件である r[i], c[i] を満たすように入力します。
    // 注: 行列積が可能であるためには、i番目の列数 c[i] と i+1番目の行数 r[i+1] が一致する必要があります。
    printf("各行列の行数(r)と列数(c)を入力してください:\n");
    for (int i = 1; i <= n; i++) {
        printf("行列 A%d (r[%d] c[%d]): ", i, i, i);
        scanf("%d %d", &r[i], &c[i]);
    }

    // --- アルゴリズム 11.6 実装開始 ---

    // 初期化: 対角成分（行列単体のコスト）は0
    for (int i = 1; i <= n; i++) {
        M[i][i] = 0;
    }

    // w は i と j の間隔を表す (連鎖させる行列の長さ - 1)
    for (int w = 1; w <= n - 1; w++) {
        // i は開始位置
        for (int i = 1; i <= n - w; i++) {
            int j = i + w; // j は終了位置
            
            // [無限の実装について]
            // アルゴリズム記載の "+∞" は、int型の最大値 INT_MAX で表現します。
            M[i][j] = INT_MAX;

            // k は分割位置
            for (int k = i; k <= j - 1; k++) {
                // コスト計算: 左側の最小コスト + 右側の最小コスト + 結合コスト
                // 画像内の式: m = M[i][k] + M[k+1][j] + r[i]*c[k]*c[j]
                long long q = (long long)M[i][k] + M[k+1][j] + (long long)r[i] * c[k] * c[j];
                
                // 最小値の更新
                if (q < M[i][j]) {
                    M[i][j] = (int)q;
                }
            }
        }
    }
    // --- アルゴリズム 11.6 実装終了 ---

    // [出力の条件]
    // 最小の演算回数 M[1][n] を出力する
    printf("最小の演算回数: %d\n", M[1][n]);

    return 0;
}