memo:
    横型探索（BFS）を実装するには・・・
    ・木構造を作る。(Tree.cで作成)
    ・木構造ではノードなどを定義する。
    ・キューにノードを入れていく
        １、根ノードをキューに入れる
        ２キューが空になるまで以下を繰り返す：
            //キューから1つノードを取り出す（Deque）
            //そのノードを処理（値を出力したり，何か調べたり）
            //そのノードの子ノードたちをすべてキューに追加（Enque）




******************Enque,Dequeの操作***********************************


    ## ✅ 前提：キューのサイズ `max = 5` の例

    ```c
    // 配列 que[0] ～ que[4] （合計5個）
    ```

    ------------------------------------------------------------

    ## 🟢 初期状態（空）

    ```
    que:   [  -  ][  -  ][  -  ][  -  ][  -  ]
    index:   0      1      2      3      4
            ↑
        front, rear（両方0）
    num = 0
    ```

    -------------------------------------------------------------

    ## 🟢 1個追加した状態（Enque）

    ```c
    Enque(&q, n1);
    ```

    ```
    que:   [ n1 ][  -  ][  -  ][  -  ][  -  ]
    index:   0      1      2      3      4
            ↑     ↑
            front   rear = 1
    num = 1
    ```

    ------------------------------------------------------------

    ## 🟢 さらに2個追加（Enque）

    ```c
    Enque(&q, n2);
    Enque(&q, n3);
    ```

    ```
    que:   [ n1 ][ n2 ][ n3 ][  -  ][  -  ]
    index:   0     1     2     3     4
            ↑                 ↑
        front             rear = 3
    num = 3
    ```

    ------------------------------------------------------------
    ## 🔄 1個取り出す（Deque）

    ```c
    Deque(&q);
    ```

    ```
    que:   [ n1 ][ n2 ][ n3 ][  -  ][  -  ]
    index:   0     1     2     3     4
                    ↑           ↑
                front       rear
    num = 2
    ```

    """"`n1` は論理的には消えていて，`front` が次（1）に進んでいる""""

    ------------------------------------------------------------
    ## 🔁 配列の末尾まで使ったあと、rearが巻き戻る

    ### さらに追加して rear が max（5）に到達した場合：

    ```c
    Enque(&q, n4);
    Enque(&q, n5); // rear = 5 → 巻き戻して rear = 0
    ```

    ```
    que:   [ n1 ][ n2 ][ n3 ][ n4 ][ n5 ]
    index:   0     1     2     3     4
                    ↑           ↑
                front       rear = 0（巻き戻し）
    num = 5（満杯）
    ```

    ------------------------------------------------------------

    ## 🔁 front も巻き戻る（Deque繰り返すと）

    ```c
    Deque(&q);  // front++
    Deque(&q);  // front++
    Deque(&q);  // front++
    Deque(&q);  // front = 5 → 巻き戻し → front = 0
    ```

    ```
    que:   [ n6 ][ - ][ - ][ - ][ - ]
    index:   0     1     2     3     4
            ↑
        front = 0
    rear = 1（新しい追加位置）
    ```

    ------------------------------------------------------------

reference:
    縦型探索、横型探索
    https://kosenjp-my.sharepoint.com/:f:/g/personal/tokumitsu_yonago-k_ac_jp/ErNPP0SrZs5OmuFQ3wV6RjMBnOPQTjklqVb_luRArm2Ggw?e=dxsfBY

    プログラムの修正は必要です。参考にしてください。

    実装の考え方
    （１）ノードを表すデータ構造を考える。リストで木構造を実現するとわかりやすい。
    （２）（１）で考えたキューまたはスタックを実現する。
    （３）縦型探索または深さ優先探索を実行する処理を実装する。

    森北出版の「アルゴリズムとデータ構造」のp.116〜は参考になるが木構造と異なる点があることを意識する。グラフは、接続のループを許すが、木構造は許さない。実装方法によるが、訪問済みのノードはスタックまたはキューと探索方法によって担保されるため、チェックしなくても実現できる。

    質問への回答
    （１）木構造は入力でどのように実現すればよいか。
    回答：木構造を入力させて、木を作成する処理は実装が大変になると思います。プログラム内で、プログラムを書いて木構造を作成する実装でよいです。

    （２）探索の際に元のデータ構造を変更してもよいか。
    探索が実装できるのであれば、元のデータ構造を変更してもよいです。